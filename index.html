<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Match App (Best Matching Method)</title>
  <!-- Tailwind CSS from CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React, ReactDOM, and Babel from CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- XLSX from CDN (optional if you want to export results) -->
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      font-family: sans-serif;
      background-color: #f9fafb; /* Tailwind gray-50 */
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">

  /***************************************************************************
   * 1) Utility Functions
   ***************************************************************************/


  // Safely parse a string or number to float. Returns null if invalid.
  function floatify(val) {
    const num = parseFloat(val);
    return isNaN(num) ? null : num;
  }

  // Example: If "Azelis Code" includes "123KG", we parse out "123"
  function splitData(s) {
    const str = String(s);
    // Look for any digits that come before "KG"
    const match = str.match(/(\d+)(?=KG)/i);
    if (match) {
      return parseFloat(match[1]);
    }
    return null;
  }

  /**
   * Jaro–Winkler Distance Implementation
   * - Returns a similarity score between 0 and 1 (1 = identical).
   *   We'll use (score * 100) to interpret it as a percentage.
   */
  function jaroWinkler(str1, str2) {
    // Clean up input
    const s1 = str1.toLowerCase().trim();
    const s2 = str2.toLowerCase().trim();

    if (s1 === s2) return 1.0;

    // The matching window is floor(maxLen/2) - 1
    const matchDist = Math.floor(Math.max(s1.length, s2.length) / 2) - 1;

    const s1Matches = new Array(s1.length).fill(false);
    const s2Matches = new Array(s2.length).fill(false);

    let matches = 0;
    let transpositions = 0;

    // 1) Find matches
    for (let i = 0; i < s1.length; i++) {
      const start = Math.max(0, i - matchDist);
      const end = Math.min(s2.length - 1, i + matchDist);

      for (let j = start; j <= end; j++) {
        if (!s2Matches[j] && s1[i] === s2[j]) {
          s1Matches[i] = true;
          s2Matches[j] = true;
          matches++;
          break;
        }
      }
    }

    if (!matches) return 0.0;

    // 2) Count transpositions
    let k = 0;
    for (let i = 0; i < s1.length; i++) {
      if (s1Matches[i]) {
        while (!s2Matches[k]) {
          k++;
        }
        if (s1[i] !== s2[k]) {
          transpositions++;
        }
        k++;
      }
    }
    transpositions = transpositions / 2.0;

    const m = matches;
    const jaro = (m / s1.length + m / s2.length + (m - transpositions) / m) / 3.0;

    // 3) Jaro–Winkler: add prefix scale
    // prefix length (max 4)
    let prefix = 0;
    for (let i = 0; i < Math.min(s1.length, s2.length, 4); i++) {
      if (s1[i] === s2[i]) {
        prefix++;
      } else {
        break;
      }
    }

    const p = 0.1; // constant scaling
    return jaro + prefix * p * (1 - jaro);
  }

  /**
   * A helper to remove special characters but keep letters, digits, and spaces.
   * Also collapses multiple spaces down to a single space.
   */
  function cleanString(str) {
    if (!str) return '';
    return str
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')  // keep letters/digits/spaces
      .replace(/\s+/g, ' ')
      .trim();
  }

  /**
   * Our new "best in the world" function to calculate scores:
   * 1) Thoroughly clean both descriptions.
   * 2) Compare them with Jaro–Winkler:
   *      - if similarity ≥ 98%, descScore=100
   *      - else fallback to word-based or abbreviation logic
   * 3) Weight Score remains the same structure as before, but slightly stricter if needed.
   */
  function calculateAllScores(azDesc, azPackWeight, supDesc, supWeight) {
    // Step 1) Clean strings
    const azDescClean = cleanString(azDesc);
    const supDescClean = cleanString(supDesc);

    let descScore = 0;
    let wtScore = 0;

    // If either description is empty, no match
    if (!azDescClean || !supDescClean) {
      return finalizeScores(0, 0);
    }

    // Step 2) Jaro–Winkler similarity
    // Convert to % out of 100
    const jwSimilarity = jaroWinkler(azDescClean, supDescClean) * 100;
    if (jwSimilarity >= 98.0) {
      // near-perfect match
      descScore = 100;
      wtScore = weightScore(azPackWeight, supWeight);
      return finalizeScores(descScore, wtScore);
    }

    // Fallback approach – Word-based partial match & Abbreviation
    descScore = fallbackWordAbbrevScore(azDescClean, supDescClean, jwSimilarity);

    // Step 3) Weight
    wtScore = weightScore(azPackWeight, supWeight);

    // Combine
    return finalizeScores(descScore, wtScore);
  }

  /**
   * Fallback scoring if we didn't get a near-perfect Jaro–Winkler match:
   *  - Use partial word overlap
   *  - Use first-letter abbreviation
   *  - Combine with the existing JW similarity as a baseline
   */
  function fallbackWordAbbrevScore(azDescClean, supDescClean, jwSimilarity) {
    // Tokenise by spaces
    const azTokens = azDescClean.split(' ');
    const supTokens = supDescClean.split(' ');

    // 1) Word-level overlap
    const azSet = new Set(azTokens);
    const supSet = new Set(supTokens);
    const common = [...azSet].filter(x => supSet.has(x));
    const maxSize = Math.max(azSet.size, supSet.size) || 1;
    const wordRatio = common.length / maxSize; // 0..1

    // 2) Abbreviation approach
    const abbr = (tokens) => tokens.map(t => t[0]).join('');
    const azAbbr = abbr(azTokens);
    const supAbbr = abbr(supTokens);
    let abbrBonus = 0;
    if (azAbbr && supAbbr && azAbbr === supAbbr) {
      abbrBonus = 10; // small bonus
    }

    // Combine:
    //  - Weighted Jaro–Winkler: 60%
    //  - Word Overlap: 30%
    //  - Abbreviation Bonus: up to 10 points
    const fallbackScore = jwSimilarity * 0.6 + wordRatio * 30 + abbrBonus;
    // Cap at 99
    return fallbackScore > 99 ? 99 : fallbackScore;
  }

  /**
   * Weight difference => a score out of 100.
   * Adjust or tighten the logic as desired.
   */
  function weightScore(azWeight, supWeight) {
    const azNum = floatify(azWeight);
    const supNum = floatify(supWeight);
    if (azNum === null || supNum === null) {
      return 0;
    }
    const diff = Math.abs(azNum - supNum);

    // Example logic:
    //   0 difference => 100
    //   up to 0.1 difference => 95
    //   up to 0.5 difference => 85
    //   bigger differences degrade further
    if (diff < 0.00001) {
      return 100;
    } else if (diff <= 0.1) {
      return 95;
    } else if (diff <= 0.5) {
      return 85;
    } else {
      // degrade further – for each full unit difference, subtract 2 points
      return Math.max(0, 85 - (diff - 0.5) * 2);
    }
  }

  /**
   * Combine description + weight into final [descScore, wtScore, totalScore].
   */
  function finalizeScores(descScore, wtScore) {
    const total = 0.7 * descScore + 0.3 * wtScore;
    return [
      parseFloat(descScore.toFixed(2)),
      parseFloat(wtScore.toFixed(2)),
      parseFloat(total.toFixed(2))
    ];
  }

  // Surcharge 1: Pack Weight
  function applyPackWeightSurcharges(lineObj, packweightRows) {
    // If no packweight data, just return
    if (!packweightRows || packweightRows.length === 0) {
      return lineObj;
    }

    const supWeight = floatify(lineObj['Matched Supplier Weight']);
    let basePrice = floatify(lineObj['Matched Supplier Price']) || 0;
    let totalPwSurcharge = 0;

    // For each pack weight surcharge rule
    for (let row of packweightRows) {
      const pwFrom = floatify(row['Pack From']);
      const pwTo = floatify(row['Pack To']);
      const addVal = floatify(row['Additional Charge']) || 0;

      // Convert missing from/to to -∞ or +∞
      const fromVal = pwFrom === null ? -Infinity : pwFrom;
      const toVal = pwTo === null ? Infinity : pwTo;

      if (supWeight !== null && supWeight >= fromVal && supWeight <= toVal) {
        totalPwSurcharge += addVal;
      }
    }

    lineObj['Pack Weight Surcharge'] = parseFloat(totalPwSurcharge.toFixed(2));
    lineObj['Matched Supplier Price'] = parseFloat(
      (basePrice + totalPwSurcharge).toFixed(2)
    );
    return lineObj;
  }

  // Surcharge 2: Logistic
  function applyLogisticSurcharges(lineObj, logisticRows) {
    if (!logisticRows || logisticRows.length === 0) {
      return [lineObj];
    }

    // We'll build an array of final lines to return
    const lines = [];
    let mainLine = { ...lineObj }; // copy
    let basePrice = floatify(mainLine['Matched Supplier Price']) || 0;
    let logisticSum = floatify(mainLine['Logistic Surcharge']) || 0;
    if (!logisticSum) logisticSum = 0;

    const supFrom = floatify(mainLine['Matched Supplier From']);
    const supTo = floatify(mainLine['Matched Supplier To']);

    // We'll track "extra lines" for logistic surcharges that don't match exactly
    const extraLines = [];

    for (let row of logisticRows) {
      let lFrom = floatify(row['Logistic From']);
      let lTo = floatify(row['Logistic To']);
      let addVal = floatify(row['Additional Charge']) || 0;

      // null => Infinity
      if (lFrom === null) lFrom = -Infinity;
      if (lTo === null) lTo = Infinity;

      // If logistic from/to EXACTLY matches sup_from/sup_to, add it
      if (lFrom === supFrom && lTo === supTo) {
        basePrice += addVal;
        logisticSum += addVal;
      } else {
        // Create new line
        const newLine = { ...mainLine };
        let newPrice = floatify(newLine['Matched Supplier Price']) || 0;
        newPrice += addVal;
        newLine['Matched Supplier From'] = `(Extra Logistic) ${lFrom}`;
        newLine['Matched Supplier To'] = `(Extra Logistic) ${lTo}`;
        newLine['Matched Supplier Price'] = parseFloat(newPrice.toFixed(2));
        newLine['Logistic Surcharge'] = parseFloat(addVal.toFixed(2));
        // Blank out the scores in the extra line
        newLine['Description Match Score'] = '';
        newLine['Weight Match Score'] = '';
        newLine['Total Score'] = '';
        extraLines.push(newLine);
      }
    }

    // Update main line
    mainLine['Matched Supplier Price'] = parseFloat(basePrice.toFixed(2));
    mainLine['Logistic Surcharge'] = parseFloat(logisticSum.toFixed(2));
    lines.push(mainLine);
    // Add extras
    lines.push(...extraLines);

    return lines;
  }

  /***************************************************************************
   * 2) Core “Process DataFrames” Logic
   ***************************************************************************/


  function processDataframes(azelisRows, supplierRows, logisticRows, packweightRows) {
    // 1) Clean and parse Azelis data
    for (let row of azelisRows) {
      const codeVal = row['Azelis Code'] || '';
      const derivedWt = splitData(codeVal);
      row['Azelis Pack Weight'] = derivedWt;
      row['Azelis Description'] = (row['Description'] || '').trim();
    }

    // 2) Clean and parse Supplier data
    for (let row of supplierRows) {
      row['Supplier Description'] = (row['Supplier Description'] || '').trim();
      row['Weight'] = floatify(row['Weight']);
    }

    // 3) Clean logistic data
    const cleanLogistic = logisticRows.filter(r =>
      (r['Logistic From'] !== '' && r['Logistic To'] !== '') ||
      r['Additional Charge'] !== ''
    ).map(r => ({
      'Logistic From': floatify(r['Logistic From']),
      'Logistic To': floatify(r['Logistic To']),
      'Additional Charge': floatify(r['Additional Charge']) || 0
    }));

    // 4) Clean pack weight data
    const cleanPackWeight = packweightRows.filter(r =>
      (r['Pack From'] !== '' && r['Pack To'] !== '') ||
      r['Additional Charge'] !== ''
    ).map(r => ({
      'Pack From': floatify(r['Pack From']),
      'Pack To': floatify(r['Pack To']),
      'Additional Charge': floatify(r['Additional Charge']) || 0
    }));

    // Group Azelis by desc
    const azelisGroups = {};
    for (let row of azelisRows) {
      const desc = (row['Azelis Description'] || '').toLowerCase();
      if (!azelisGroups[desc]) {
        azelisGroups[desc] = [];
      }
      azelisGroups[desc].push(row);
    }

    // Group Supplier by desc
    const supplierGroups = {};
    for (let row of supplierRows) {
      const desc = (row['Supplier Description'] || '').toLowerCase();
      if (!supplierGroups[desc]) {
        supplierGroups[desc] = [];
      }
      supplierGroups[desc].push(row);
    }

    const finalRows = [];
    const scoreThreshold = 30.0;  // same as your original code

    // For each Azelis desc group
    for (let [azDesc, azRows] of Object.entries(azelisGroups)) {
      // Find all matching supplier descriptions above threshold
      let bestMatches = [];
      let bestScore = -1;

      // Compare azDesc vs. each supplier desc
      for (let [supDesc, supRows] of Object.entries(supplierGroups)) {
        // Only scoring desc, ignoring weights
        const [dScore] = calculateAllScores(azDesc, null, supDesc, null);
        if (dScore >= scoreThreshold) {
          bestMatches = bestMatches.concat(supRows);
          if (dScore > bestScore) {
            bestScore = dScore;
          }
        }
      }

      if (bestMatches.length === 0) {
        // No matching supplier group => push "No Match Found" for each Azelis row
        for (let azRow of azRows) {
          finalRows.push({
            'Azelis Code': azRow['Azelis Code'] || '',
            'Azelis Description': azRow['Azelis Description'] || '',
            'Azelis Pack Weight': floatify(azRow['Azelis Pack Weight']) || '',
            'Matched Supplier Description': 'No Match Found',
            'Matched Supplier SKU': '',
            'Matched Supplier Weight': '',
            'Matched Supplier Price': '',
            'Matched Supplier From': '',
            'Matched Supplier To': '',
            'Pack Weight Surcharge': '',
            'Logistic Surcharge': '',
            'Description Match Score': '',
            'Weight Match Score': '',
            'Total Score': ''
          });
        }
        continue;
      }

      // Group bestMatches by description+weight
      const descWeightGroups = {};
      for (let supRow of bestMatches) {
        const supDesc = (supRow['Supplier Description'] || '').toLowerCase();
        const supWeight = floatify(supRow['Weight']);
        const groupKey = `${supDesc}|${supWeight}`;
        if (!descWeightGroups[groupKey]) {
          descWeightGroups[groupKey] = [];
        }
        descWeightGroups[groupKey].push(supRow);
      }

      // Process each Azelis row in the group
      for (let azRow of azRows) {
        const azWeight = floatify(azRow['Azelis Pack Weight']);

        // Find best match by closest weight & best desc
        let bestGroupKey = null;
        let bestWeightDiff = Infinity;
        let bestDescScore = -1;

        for (let [groupKey, supRows] of Object.entries(descWeightGroups)) {
          const supRow = supRows[0];
          const supWt = floatify(supRow['Weight']);
          const supDesc = supRow['Supplier Description'];
          
          const [dScore] = calculateAllScores(
            azRow['Azelis Description'],
            null,
            supDesc,
            null
          );

          if (azWeight !== null && supWt !== null) {
            const weightDiff = Math.abs(azWeight - supWt);
            // Prioritise weight match if description scores are close
            // e.g. if dScore within 5 points of bestDescScore, compare weight
            if (dScore >= bestDescScore - 5) {
              if (weightDiff < bestWeightDiff) {
                bestWeightDiff = weightDiff;
                bestGroupKey = groupKey;
                bestDescScore = dScore;
              }
            } else if (dScore > bestDescScore) {
              bestWeightDiff = weightDiff;
              bestGroupKey = groupKey;
              bestDescScore = dScore;
            }
          }
        }

        if (bestGroupKey) {
          // Create entry for each "price break" row in that description+weight group
          for (let supRow of descWeightGroups[bestGroupKey]) {
            const supWeight = supRow['Weight'];
            const supDesc = supRow['Supplier Description'];
            const supPrice = supRow['Price'];
            const supFrom = supRow['From'];
            const supTo = supRow['To'];

            const [dScore, wScore, tScore] = calculateAllScores(
              azRow['Azelis Description'],
              azWeight,
              supDesc,
              supWeight
            );

            let lineObj = {
              'Azelis Code': azRow['Azelis Code'] || '',
              'Azelis Description': azRow['Azelis Description'] || '',
              'Azelis Pack Weight': azWeight !== null ? azWeight : '',
              'Matched Supplier Description': supDesc || '',
              'Matched Supplier SKU': supRow['SKU'] || '',
              'Matched Supplier Weight': supWeight !== null ? supWeight : '',
              'Matched Supplier Price': floatify(supPrice) || 0,
              'Matched Supplier From': supFrom || '',
              'Matched Supplier To': supTo || '',
              'Pack Weight Surcharge': 0,
              'Logistic Surcharge': 0,
              'Description Match Score': dScore,
              'Weight Match Score': wScore,
              'Total Score': tScore
            };

            // Apply pack weight surcharges
            lineObj = applyPackWeightSurcharges(lineObj, cleanPackWeight);

            // Apply logistic surcharges => may produce multiple lines
            let linesAfterLogistics = applyLogisticSurcharges(lineObj, cleanLogistic);

            finalRows.push(...linesAfterLogistics);
          }
        } else {
          // No weight match found
          finalRows.push({
            'Azelis Code': azRow['Azelis Code'] || '',
            'Azelis Description': azRow['Azelis Description'] || '',
            'Azelis Pack Weight': azWeight !== null ? azWeight : '',
            'Matched Supplier Description': 'No Weight Match Found',
            'Matched Supplier SKU': '',
            'Matched Supplier Weight': '',
            'Matched Supplier Price': '',
            'Matched Supplier From': '',
            'Matched Supplier To': '',
            'Pack Weight Surcharge': '',
            'Logistic Surcharge': '',
            'Description Match Score': bestScore,
            'Weight Match Score': '',
            'Total Score': ''
          });
        }
      }
    }

    return finalRows;
  }

  /***************************************************************************
   * 3) EditableTable + Main React App
   ***************************************************************************/


  const Alert = ({ children }) => {
    return (
      <div className="mb-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
        {children}
      </div>
    );
  };

  // Table for entering data
  const EditableTable = ({ columns, data, setData }) => {
    const handlePaste = (e, rowIndex, colIndex) => {
      e.preventDefault();
      const pastedText = e.clipboardData.getData('text');
      const rows = pastedText.split(/\r\n|\n|\r/).filter(row => row.trim());
      
      // Split each row by tabs or multiple spaces
      const pastedData = rows.map(row => row.split(/\t|\s{2,}/));

      setData(current => {
        const newData = [...current];
        pastedData.forEach((rowVals, i) => {
          const targetRow = rowIndex + i;
          while (newData.length <= targetRow) {
            // add empty row
            const emptyRow = {};
            columns.forEach(col => (emptyRow[col.key] = ''));
            newData.push(emptyRow);
          }

          rowVals.forEach((cell, j) => {
            const colKey = columns[colIndex + j]?.key;
            if (colKey) {
              newData[targetRow][colKey] = cell.trim();
            }
          });
        });
        return newData;
      });
    };

    const handleChange = (rowIndex, colKey, value) => {
      setData(current => {
        const newData = [...current];
        newData[rowIndex] = { ...newData[rowIndex], [colKey]: value };
        return newData;
      });
    };

    return (
      <div className="border rounded" style={{ height: '600px' }}>
        <div className="overflow-auto h-full">
          <table className="w-full table-fixed bg-white">
            <thead className="sticky top-0 bg-gray-50 z-10">
              <tr>
                {columns.map(col => (
                  <th
                    key={col.key}
                    className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-r"
                    style={{ width: col.width || '150px' }}
                  >
                    {col.label}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {data.map((row, r) => (
                <tr key={r} className="border-b hover:bg-gray-50">
                  {columns.map((col, c) => (
                    <td key={col.key} className="border-r p-0">
                      <input
                        type="text"
                        value={row[col.key] || ''}
                        onChange={(e) => handleChange(r, col.key, e.target.value)}
                        onPaste={(e) => handlePaste(e, r, c)}
                        className="w-full h-8 px-3 border-0 focus:ring-1 focus:ring-blue-500 focus:ring-opacity-50 focus:outline-none"
                      />
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    );
  };

  const MatchApp = () => {
    const [activeTab, setActiveTab] = React.useState('azelis');
    const [error, setError] = React.useState('');
    const [results, setResults] = React.useState([]);

    // We want 4 tables: Azelis, Supplier, Logistic, PackWeight
    const createRows = (cols, count=1000) => {
      const emptyRow = {};
      cols.forEach(c => { emptyRow[c.key] = ''; });
      return Array.from({ length: count }, () => ({ ...emptyRow }));
    };

    // Table definitions
    const tableDefs = {
      azelis: {
        columns: [
          { key: 'Azelis Code', label: 'Azelis Code', width: '150px' },
          { key: 'Description', label: 'Description', width: '300px' }
        ]
      },
      supplier: {
        columns: [
          { key: 'Supplier Description', label: 'Supplier Description', width: '300px' },
          { key: 'SKU', label: 'SKU' },
          { key: 'Weight', label: 'Weight' },
          { key: 'Price', label: 'Price' },
          { key: 'From', label: 'From' },
          { key: 'To', label: 'To' }
        ]
      },
      logistic: {
        columns: [
          { key: 'Logistic From', label: 'Logistic From' },
          { key: 'Logistic To', label: 'Logistic To' },
          { key: 'Additional Charge', label: 'Additional Charge' }
        ]
      },
      packweight: {
        columns: [
          { key: 'Pack From', label: 'Pack From' },
          { key: 'Pack To', label: 'Pack To' },
          { key: 'Additional Charge', label: 'Additional Charge' }
        ]
      }
    };

    // Initialise data
    const [azelisData, setAzelisData] = React.useState(
      createRows(tableDefs.azelis.columns, 500)
    );
    const [supplierData, setSupplierData] = React.useState(
      createRows(tableDefs.supplier.columns, 500)
    );
    const [logisticData, setLogisticData] = React.useState(
      createRows(tableDefs.logistic.columns, 200)
    );
    const [packweightData, setPackweightData] = React.useState(
      createRows(tableDefs.packweight.columns, 200)
    );

    // Add row to the active table
    const addRow = () => {
      switch (activeTab) {
        case 'azelis':
          setAzelisData(current => [...current, {}]);
          break;
        case 'supplier':
          setSupplierData(current => [...current, {}]);
          break;
        case 'logistic':
          setLogisticData(current => [...current, {}]);
          break;
        case 'packweight':
          setPackweightData(current => [...current, {}]);
          break;
      }
    };

    // Helper for returning data+setter for the active tab
    const getActiveTable = () => {
      switch (activeTab) {
        case 'azelis': return { data: azelisData, setData: setAzelisData, columns: tableDefs.azelis.columns };
        case 'supplier': return { data: supplierData, setData: setSupplierData, columns: tableDefs.supplier.columns };
        case 'logistic': return { data: logisticData, setData: setLogisticData, columns: tableDefs.logistic.columns };
        case 'packweight': return { data: packweightData, setData: setPackweightData, columns: tableDefs.packweight.columns };
        default: return { data: [], setData: () => {}, columns: [] };
      }
    };

    // Filter out truly empty rows
    function cleanRows(rows, columns) {
      return rows.filter(r =>
        columns.some(col => String(r[col.key] || '').trim() !== '')
      );
    }

    // PROCESS DATA
    const processData = () => {
      try {
        const azelisCols = tableDefs.azelis.columns;
        const supplierCols = tableDefs.supplier.columns;
        const logisticCols = tableDefs.logistic.columns;
        const packweightCols = tableDefs.packweight.columns;

        const cleanAzelis = cleanRows(azelisData, azelisCols);
        const cleanSupplier = cleanRows(supplierData, supplierCols);
        const cleanLogistic = cleanRows(logisticData, logisticCols);
        const cleanPackweight = cleanRows(packweightData, packweightCols);

        const finalRows = processDataframes(
          cleanAzelis,
          cleanSupplier,
          cleanLogistic,
          cleanPackweight
        );

        setResults(finalRows);
        setError('');
      } catch (err) {
        setError('Error processing data: ' + err.message);
      }
    };

    // Export results to Excel
    const exportResults = () => {
      if (results.length === 0) return;
      const ws = XLSX.utils.json_to_sheet(results);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Results");
      XLSX.writeFile(wb, "match_results.xlsx");
    };

    // Reset everything
    const resetAll = () => {
      setAzelisData(createRows(tableDefs.azelis.columns, 500));
      setSupplierData(createRows(tableDefs.supplier.columns, 500));
      setLogisticData(createRows(tableDefs.logistic.columns, 200));
      setPackweightData(createRows(tableDefs.packweight.columns, 200));
      setResults([]);
      setError('');
    };

    // Render
    const currentTab = getActiveTable();

    return (
      <div className="max-w-full p-4">
        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
          <h1 className="text-2xl font-bold mb-4">Match App (Best Matching Method)</h1>

          <div className="flex gap-4 mb-4">
            <button
              onClick={processData}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Process Data
            </button>
            <button
              onClick={exportResults}
              disabled={results.length === 0}
              className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 
                        disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Export Results
            </button>
            <button
              onClick={resetAll}
              className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
            >
              Reset
            </button>
          </div>

          {error && <Alert>{error}</Alert>}

          <div className="mb-4">
            <div className="border-b border-gray-200">
              <nav className="-mb-px flex space-x-8">
                {Object.keys(tableDefs).map(tab => (
                  <button
                    key={tab}
                    onClick={() => setActiveTab(tab)}
                    className={`border-b-2 px-1 py-4 text-sm font-medium
                      ${activeTab === tab
                        ? 'border-blue-500 text-blue-600'
                        : 'border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700'
                      }`}
                  >
                    {tab.charAt(0).toUpperCase() + tab.slice(1)} Data
                  </button>
                ))}
              </nav>
            </div>

            <div className="mt-4">
              <div className="mb-2 text-sm text-gray-600">
                Tip: Paste data directly from Excel. Select the cell where you want to start pasting.
              </div>
              <EditableTable
                columns={currentTab.columns}
                data={currentTab.data}
                setData={currentTab.setData}
              />
              <div className="mt-2">
                <button
                  onClick={addRow}
                  className="px-2 py-1 bg-gray-200 text-sm rounded hover:bg-gray-300"
                >
                  + Add Row
                </button>
              </div>
            </div>
          </div>

          {results.length > 0 && (
            <div className="mt-4 overflow-x-auto">
              <h2 className="text-xl font-bold mb-2">Results</h2>
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    {Object.keys(results[0]).map(header => (
                      <th
                        key={header}
                        className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                      >
                        {header}
                      </th>
                    ))}
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {results.map((row, idx) => (
                    <tr key={idx}>
                      {Object.entries(row).map(([key, value]) => (
                        <td
                          key={key}
                          className="px-6 py-4 whitespace-nowrap text-sm text-gray-500"
                        >
                          {value}
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
        <div className="text-sm text-gray-500">Created by Greg Michell</div>
      </div>
    );
  };

  // Render
  ReactDOM.render(<MatchApp />, document.getElementById('root'));
  </script>
</body>
</html>
